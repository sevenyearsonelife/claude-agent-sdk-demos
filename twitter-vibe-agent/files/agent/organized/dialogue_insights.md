# 用户理解与困惑

## 已理解

### 核心概念理解
- GraphRAG 不是"用图做检索"，而是"离线语义蒸馏 + 在线聚合"系统
- 文本→图谱（结构化）→社区摘要（语义压缩）→map-reduce 查询
- 社区摘要才是查询时的核心索引，图谱在 query-time 可以完全冷冻

### 关键机制理解
- Text chunks 只在索引阶段作为"证据单元"，查询时不用
- 社区发现通过 Leiden 算法递归生成层级结构
- Map-reduce 是 Query-Focused Summarization，不是传统检索
- 层级数量不是人工指定，而是由数据+停止条件决定

### 工程实践认知
- GraphRAG 主要成本在 build 阶段（大量 LLM 调用）
- Global query 的 map 阶段最吃 token
- 本体设计需要专家介入，LLM 只能"枚举世界"，人类决定"什么重要"
- 可以通过分层路由、向量预筛选、缓存等方法优化 token 消耗

### 与传统方法对比
- Vector RAG：适合局部事实检索，但无法做全局 sensemaking
- GraphRAG：牺牲成本换取全局理解能力
- Local 查询可以用子图/局部摘要，不需要跑全量 map-reduce

## 困惑点

### 层级与查询流程
- 一开始误以为 map-reduce 是"多层逐级 reduce"（C0→C1→C2→C3）
- 实际：一次查询只选一个层级，跑一次 map-reduce
- 困惑根源：没有区分"索引层的层级性"和"查询流程的单层性"

### Text Chunks 的角色
- 困惑：为什么 GraphRAG 不用 chunks 检索？
- 原因：chunks 只负责"把文本变成结构"，完成后就丢掉
- 查询时用的是"已经蒸馏好的社区摘要"

### 社区摘要的存储
- 困惑：摘要存在哪里？是图的一部分吗？
- 实际：摘要是"派生索引层"，不是图节点
- 通过 community_id 反查到 node_ids/edge_ids/claim_ids

### 层级选择机制
- 困惑：GraphRAG 如何自动知道该用哪一层？
- 实际：GraphRAG 不会自动决定，需要外部策略
- 可以固定、启发式规则、或用户指定

### Local vs Global 查询的界限
- 困惑：GraphRAG 是否只支持全局问题？
- 实际：核心设计目标是 global，但也支持 local
- Local 问题可以用更便宜的路径（子图摘要）

### Token 成本的来源
- 困惑：为什么大家说 GraphRAG 特别贵？
- 主要原因：
  1. Build 阶段大量 LLM 调用
  2. Global query 的 map 阶段可能处理大量摘要
  3. 用 C2/C3 等细粒度层级会指数级增加 token

### 本体设计的必要性
- 困惑：LLM 能不能自动完成本体设计？
- 理解演进：
  1. 最初以为可以完全自动化
  2. 意识到 LLM 默认行为是"覆盖最大化"
  3. 理解"本体=压缩策略"是工程决策，不是 NLP 问题

## 目标受众/岗位

### 目标岗位
- **算法工程师**（特别是 RAG/搜索/NLP 方向）
- **知识图谱工程师**
- **AI 系统架构师**
- **LLM 应用开发工程师**

### 知识背景假设
- 熟悉传统向量 RAG 的工作原理
- 了解基本的图概念（节点、边、社区）
- 知道 LLM 的基本限制（context window、token 成本）
- 对知识图谱有一定概念

### 面试场景定位
- 技术深度考察：不只问"是什么"，更要问"为什么"、"如何权衡"
- 系统设计能力：如何为特定场景选择/设计 GraphRAG
- 工程思维：成本优化、可维护性、可评估性

## 难度偏好

### 基础难度（应届/初级）
- 知道 GraphRAG 是什么，解决什么问题
- 理解基本的 pipeline 流程
- 知道与传统 RAG 的区别
- 能解释社区、实体、关系等基本概念

### 进阶难度（中级/3-5年）
- 理解 GraphRAG 的设计动机和本质
- 能解释 map-reduce 的 QFS 本质
- 知道如何选择层级、优化 token
- 理解本体设计的重要性
- 能分析不同查询类型的适用路径

### 专家难度（高级/5+年）
- 从信息论/压缩视角理解 GraphRAG
- 能设计混合策略（GraphRAG + vector RAG + routing）
- 理解评估指标的选择和 LLM-as-a-judge 方法
- 能权衡成本、质量、可维护性
- 能提出改进方向（如弱化图谱、强化摘要与路由）

## 风格偏好

### 技术风格
- **严谨但易懂**：避免堆砌术语，用具体例子说明
- **原因驱动**：不只讲"怎么做"，更要讲"为什么"
- **对比思维**：通过与 vector RAG、传统 KG-RAG 对比来突出特点

### 口吻定位
- 可以是**面试官视角**（考察候选人理解深度）
- 也可以是**技术分享视角**（向团队/社区介绍 GraphRAG）
- 避免：纯学术风（太抽象）、纯营销风（太浅）

### 语气强度
- **友好但专业**：允许困惑，但引导到正确理解
- **适度犀利**：指出常见误区，但不贬低
- **建设性**：不仅讲现状，还延伸到改进方向

## 禁用项/避免

### 内容禁用
- 不要复述论文全文（只提取可出题线索）
- 不要混入个人主观评价（除非是"常见误区"）
- 不要写完整的面试题答案框架（只给要点和追问方向）

### 格式禁用
- 不使用 emoji
- 不用 markdown 表格（用列表替代）
- 不用加粗强调关键词（用清晰的层次结构）

### 理解禁用
- 避免"GraphRAG 就是某种 RAG 变体"的浅层理解
- 避免"层级是递归 reduce"的错误模型
- 避免"LLM 能完全自动化"的过度乐观
- 避免"GraphRAG 适合所有场景"的万能论

### 混淆禁用
- 不要混淆 GraphRAG 的 local 查询与 vector RAG
- 不要混淆 indexing time 和 query time 的数据流
- 不要混淆社区摘要和图节点的关系
- 不要混淆层级数量（自动）和层级选择（手动）

## 可出题方向总结

### 高频考察点
1. GraphRAG 与 vector RAG 的本质区别
2. Text chunks 在 GraphRAG 中的作用
3. 社区发现和层级摘要的生成机制
4. Map-reduce 查询流程（不是多层 reduce）
5. 本体设计的必要性和权衡
6. Token 成本优化策略
7. Local vs Global 查询的选择
8. 评估方法和指标选择

### 进阶考察点
1. 从信息论/压缩视角理解 GraphRAG
2. 层级选择的启发式规则设计
3. Hybrid RAG 策略设计
4. 可解释性和可追溯性实现
5. Schema 变更的影响范围
6. 不同领域的本体设计经验

### 专家考察点
1. GraphRAG 的理论局限和改进方向
2. 如何设计自适应的层级选择机制
3. 如何平衡成本、质量、可维护性
4. GraphRAG 与其他先进 RAG 方法的融合
5. 大规模 GraphRAG 的工程挑战
