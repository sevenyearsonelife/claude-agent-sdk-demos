# 文章补充细节

## 可出题线索

### 【问题种子】Claude Code 的核心架构是什么？
- 【考察点】单线程主循环设计、工具调用机制、扁平化消息列表
- 【回答要点】nO 主循环引擎（AgentLoop），遵循 while(tool_call) → execute → observe → repeat 模式
- 【常见误区】误认为是多智能体蜂群架构，实际是单线程加受控分支
- 【可追问】为什么选择单线程而非多智能体？如何实现可调试性？
- 【层级区分】基础：说出循环模式；进阶：解释设计哲学；专家：对比多智能体架构优劣

### 【问题种子】h2A 异步消息队列如何实现实时转向？
- 【考察点】双重缓冲机制、Promise 异步迭代器、零延迟路径
- 【回答要点】基于 Promise 的异步迭代器，支持暂停/恢复，消息可直接注入队列
- 【常见误区】认为是简单的轮询队列，实际是零延迟直通机制
- 【可追问】如何实现每秒 10,000+ 条消息吞吐？背压控制如何工作？
- 【层级区分】基础：支持中途干预；进阶：双重缓冲机制；专家：Promise 实现原理

### 【问题种子】Compressor wU2 何时触发上下文压缩？
- 【考察点】上下文窗口管理、压缩阈值、智能评分算法
- 【回答要点】达到上下文窗口约 92% 时自动触发，总结并转移到长期存储
- 【常见误区】认为简单截断旧信息，实际是智能重要性评分压缩
- 【可追问】保留比率是多少？压缩后的信息存到哪里？
- 【层级区分】基础：92% 阈值；进阶：三层存储策略；专家：重要性评分算法

### 【问题种子】为什么 Claude Code 选择 Regex 而非向量数据库？
- 【考察点】设计哲学、模型能力利用、工程权衡
- 【回答要点】模型足够聪明构建复杂正则，避免维护搜索索引的开销
- 【常见误区】认为向量数据库更先进，实际是"激进的简单性"原则
- 【可追问】什么场景下向量数据库更合适？Regex 的局限性是什么？
- 【层级区分】基础：简单工具优先；进阶：计算套利概念；专家：精确匹配 vs 语义搜索

### 【问题种子】Claude Code 如何处理子代理派生？
- 【考察点】受控并行、深度限制、递归爆炸防护
- 【回答要点】最多一个子代理分支（I2A），禁止递归派生，结果反馈回主循环
- 【常见误区】认为可以无限派生子代理，实际有严格数量和深度限制
- 【可追问】为什么限制为"一个"？子代理权限如何隔离？
- 【层级区分】基础：最多一个分支；进阶：防止递归爆炸；专家：隔离环境安全机制

### 【问题种子】Codex CLI 的核心操作循环是什么？
- 【考察点】ReAct 模式、Shell 优先设计、单代理架构
- 【回答要点】单代理 ReAct 风格循环（思考→工具调用→观察→重复），Shell 命令执行器
- 【常见误区】认为需要专用 API，实际依赖 Unix 标准工具
- 【可追问】apply_patch 命令如何工作？系统提示词如何约束行为？
- 【层级区分】基础：ReAct 循环；进阶：Shell 优先哲学；专家：提示词工程细节

### 【问题种子】diff-centric 编辑理念的优势是什么？
- 【考察点】上下文效率、可审查性、幻觉风险控制
- 【回答要点】节省 Token、红绿对比可审查、降低重写文件引入错误风险
- 【常见误区】认为整文件重写更简单，实际 diff 模式更安全高效
- 【可追问】如何处理大文件编辑？用户审批流程如何设计？
- 【层级区分】基础：节省 Token；进阶：人类在环控制；专家：外科手术式补丁机制

### 【问题种子】Codex 的沙箱隔离机制是什么？
- 【考察点】OS 级隔离、Seatbelt/Docker、网络阻断
- 【回答要点】macOS 使用 Seatbelt，Linux 使用 Docker + iptables，只允许访问项目目录和 OpenAI API
- 【常见误区】认为应用层权限控制足够，实际需要内核级硬隔离
- 【可追问】与 Claude Code 的权限系统有何区别？网络隔离如何实现？
- 【层级区分】基础：Seatbelt/Docker；进阶：强制访问控制；专家：跨平台隔离差异

### 【问题种子】懒加载 vs 主动扫描的权衡是什么？
- 【考察点】上下文管理策略、Token 效率、幻觉风险
- 【回答要点】懒加载低 Token 但可能缺失上下文，主动扫描全面但消耗资源
- 【常见误区】认为加载越多越好，实际需要根据任务类型选择
- 【可追问】如何缓解懒加载的"隧道视野"？主动扫描如何优化？
- 【层级区分】基础：概念区别；进阶：适用场景；专家：混合策略设计

### 【问题种子】CLAUDE.md 文件的核心作用是什么？
- 【考察点】长期记忆存储、项目上下文、配置工程
- 【回答要点】项目的"入职手册"，存储架构、开发指南、项目概览
- 【常见误区】认为是可选文档，实际是 AI 理解项目的必要条件
- 【可追问】最常见的配置模式是什么？与 AGENTS.md 的区别？
- 【层级区分】基础：存储项目信息；进阶：架构模式占比；专家：实证研究数据

## 机制/原理要点

### nO 主循环引擎
- 基于异步生成器（AsyncGenerator）实现
- 伪代码：while(tool_call) → execute tool → feed results → repeat
- 维护扁平化消息列表（Flat list of messages）
- 纯文本响应时循环终止，交还控制权
- 负责任务调度、状态管理、多层异常处理

### h2A 异步消息队列
- 双重缓冲机制（Dual-buffer Queue）
- 零延迟路径：消费者等待时直接通过 Promise 传递
- 缓冲路径：消费者忙碌时消息存入 primaryBuffer
- 智能背压控制：防止内存溢出
- 支持每秒 10,000+ 条消息吞吐量

### Compressor wU2 压缩器
- 触发阈值：上下文窗口使用率约 92%
- 智能重要性评分算法（Importance Scoring）
- 压缩比率：约保留 30%（preserveRatio: 0.3）
- 三层存储：当前消息 → 压缩历史摘要 → CLAUDE.md

### dispatch_agent / I2A 子代理
- 内部代号：I2A 或 Task Agent
- 隔离执行环境，独立权限范围
- 深度限制：不能递归派生子代理
- 数量限制：最多一个活跃分支
- 结果以文本形式反馈回主循环

## 工程实践/经验

### 328 个 CLAUDE.md 文件实证研究
- 软件架构（72.6%）：包结构、核心接口、模块化原则
- 开发指南（44.8%）：类型提示、依赖管理、代码风格
- 项目概览（39%）：业务领域、核心功能
- 测试（35.4%）：测试策略、具体命令
- 常用命令（33.2%）：构建、测试、类型检查

### 最常见配置模式
- "架构 + 依赖 + 项目概述"（21.6%）
- 被称为"最小可行上下文（Minimum Viable Context）"

### 工具使用模式
- Claude Code：显式规划（TodoWrite + /think 模式）
- Codex：隐式规划（动作即计划）

### 文件编辑策略
- apply_patch：生成 unified diff，红绿对比审查
- 外科手术式补丁：最小化修改而非整文件重写

## 数据/指标/对比

### 性能指标
- h2A 吞吐量：>10,000 条消息/秒
- Compressor 触发阈值：92% 上下文占用率
- 压缩保留比率：约 30%

### 并发控制
- Claude Code：最多 10 个工具并发执行
- 子代理分支：最多 1 个

### 对比表格
| 特性 | Claude Code | Codex CLI |
|------|------------|-----------|
| 架构模式 | 单线程 + 受控分支 | 单代理 ReAct |
| 工具设计 | 结构化工具箱 | Shell 优先 |
| 上下文加载 | 主动扫描 | 懒加载 |
| 沙箱实现 | 应用层权限 | OS 级隔离 |
| 规划方式 | 显式（TodoWrite） | 隐式 |
| 指令文件 | CLAUDE.md | AGENTS.md |

## 案例/比喻

### 厨房类比（nO + h2A）
- nO = 专注的主厨，一次只做一道菜
- h2A = 传菜员，能实时递送顾客修改意见
- 零延迟路径 = 主厨等待时直接听到指令
- 缓冲路径 = 主厨忙碌时订单写在白板上

### 图书馆类比（Regex vs 向量数据库）
- 向量数据库 = 维护数字化目录系统，每进新书都要录入
- Claude Code = 过目不忘的图书管理员，写纸条直接定位书籍

### 装修类比（子代理管理）
- 主代理 = 承包商，统筹全局
- 子代理 = 专业电工，单一任务
- 限制 = 电工不能再雇佣其他人，必须自己干完

### 自助餐 vs 点菜（上下文加载）
- Claude Code = 自助餐，先端上来各种盘子
- Codex = 点菜，看菜单只点要吃的

## 关键术语解释

### Radical Simplicity（激进的简单性）
- Anthropic 的核心工程原则
- 选择简单可靠的技术而非复杂方案
- "做简单的事（Do the simple thing first）"

### ReAct Loop
- Reasoning + Acting 循环模式
- 思考 → 行动 → 观察 → 重复
- 代理系统的经典执行模式

### Controlled Parallelism（受控并行）
- 单线程主循环 + 受限的子代理分支
- 拒绝多智能体蜂群（Swarms）
- 保证可调试性和线性审计跟踪

### Surgical Patches（外科手术式补丁）
- 最小化的、精确的代码修改
- 生成 unified diff 而非重写整个文件
- 降低引入新错误的风险

### Audit Trail（审计跟踪）
- 线性的、可追溯的操作记录
- 单线程架构的自然产物
- 便于调试和错误定位

### Recursive Explosion（递归爆炸）
- 子代理无限自我复制导致系统崩溃
- Claude Code 通过深度限制防止此问题
- 最多允许一层子代理

### Importance Scoring（重要性评分）
- Compressor wU2 的核心算法
- 评估对话中哪些部分对后续任务至关重要
- 决定压缩时保留哪些信息
