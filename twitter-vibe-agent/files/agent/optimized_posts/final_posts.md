# 最终帖子

## Post 1

【面试题】Claude Code 与 Codex 的核心架构差异是什么？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| Agent 循环设计 / 工具哲学 / 并行控制策略 | 高频 | 进阶 |

回答要点：Claude Code 采用 nO 单线程主循环 + h2A 异步队列 + 受控子代理（I2A，最多 1 分支且禁止递归）；Codex 采用标准 ReAct 循环（Think-Tool-Observe）+ Shell 优先执行器，无并行分支。前者主循环基于异步生成器，while(tool_call)→execute→observe→repeat；后者系统提示词硬编码行为模式。

常见误区：认为两者都是多智能体蜂群架构。实际两者都是单代理设计，区别在于工具封装层次和并行控制粒度。

追问：为什么 Claude Code 限制子代理递归派生？Codex 的懒加载策略在什么场景下会失效？

区分度：基础层知道都是单代理；进阶层理解工具哲学差异（结构化工具 vs Shell 原生命令）；专家层掌握 h2A 零延迟路径与背压控制机制。

## Post 2

【面试题】两者如何处理文件编辑和搜索？为何都偏好 diff 而非全文输出？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| diff-centric 编辑理念 / Regex vs Shell 搜索 / Token 效率与可审查性 | 中高 | 进阶 |

回答要点：Claude Code 用 GrepTool（Regex 实现）+ Edit 工具；Codex 用 Shell 命令（grep/find）+ apply_patch（生成统一差异格式）。两者都只输出变更部分，不重写整个文件。diff 编辑节省 60-80% Token，同时增强可审查性（红绿高亮）并降低幻觉风险（模型只需关注局部变更）。

常见误区：认为 Codex 会读取并重写整个文件。实际 apply_patch 拦截 diff 输出后内部解析，模型只接触变更内容。

追问：diff 编辑在什么场景下会失效？apply_patch 的安全审查流程如何设计？为什么压缩历史中也要保留 diff 格式？

区分度：基础层知道用 diff；进阶层理解 Token 效率优势；专家层掌握统一差异格式规范和冲突处理策略。

## Thread 1/3

【面试题】Claude Code 如何解决上下文窗口限制？wU2 压缩器的设计思路是什么？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 上下文管理 / 三层存储策略 / 重要性评分算法 | 中 | 专家 |

回答要点：Claude Code 实现短期记忆（当前会话）→ 中期压缩历史 → 长期存储（CLAUDE.md）三级架构。wU2 压缩器在上下文窗口占用 92% 时触发，基于重要性评分算法压缩历史对话，保留约 30% 关键信息。压缩结果注入后续会话，确保模型能追溯任务上下文。

设计哲学：激进简单性——用 Markdown 而非数据库存储，依赖模型自身推理能力而非外部向量检索。压缩判断基于消息类型（工具结果优先保留）、用户指令显式标记、对话时间衰减。

常见误区：认为压缩是简单文本截断或 LLM 摘要。实际是基于规则+评分的结构化筛选。

追问：如何量化"重要性"？压缩比 30% 是经验值还是可调参数？为什么不用 RAG 检索替代压缩？

区分度：基础层知道会压缩；进阶层理解 92% 阈值和三层设计；专家层掌握评分算法和 CLAUDE.md 持久化策略。

## Thread 2/3

【追问深入】wU2 压缩算法如何判断信息重要性？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 重要性评分规则 / 规则启发式 / 上下文保留策略 | 低 | 专家 |

回答要点扩展：优先级规则包括（1）工具调用及其返回值高于纯对话文本；（2）TODO 状态更新高于普通输出；（3）用户显式标记（如"记住这个"）最高优先；（4）时间衰减：最近 10 轮对话权重翻倍；（5）错误和失败操作优先保留（便于调试）。

工程实现：压缩不调用额外 LLM，避免成本爆炸和延迟。用启发式规则 + TF-IDF 变种评分，保留代码块、配置内容等高信息密度片段。

边界条件：压缩在会话级生效，不跨会话持久化；CLAUDE.md 手动维护，包含架构、依赖、项目概览三元组。

追问：如何评估压缩是否丢失关键信息？用户能否干预压缩结果？

## Thread 3/3

【实战场景】Codex 的懒加载策略 vs Claude Code 的主动扫描，各有什么陷阱？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 上下文加载策略 / 工程权衡 / 实战选择 | 中 | 进阶 |

Codex 懒加载：仅读取显式请求的文件，依赖 AGENTS.md 全局地图和 Git 历史补充上下文。优点是启动快、Token 消耗低；缺点是在大型 monorepo 中可能遗漏跨模块依赖，需要用户明确指定或配置完善。

Claude Code 主动扫描：会话启动时扫描项目结构，构建代码库心智模型。优点是对复杂重构更友好，自动发现依赖；缺点是初期 Token 消耗大，可能在巨型项目中触发过早的上下文压缩。

实战选择：外科手术式 bug 修复选 Codex；大规模架构调整选 Claude Code。混合策略是理想方案：启动时轻量扫描（目录树+配置文件），按需深度读取。

追问：如何设计自适应加载策略？AGENTS.md 的分层继承如何避免配置冲突？

## Post 3

【面试题】两者如何实现沙箱隔离？OS 级隔离与应用级隔离的本质区别是什么？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 安全架构 / Seatbelt-Docker 机制 / 权限控制粒度 | 高频 | 进阶 |

回答要点：Codex 采用 OS 级沙箱——macOS 用 Seatbelt 沙箱（限制文件系统访问，仅允许读写指定目录，网络白名单仅含 OpenAI API）；Linux 用 Docker 容器 + iptables 限制网络。这是强制访问控制，即使模型被攻破也无法逃逸。

Claude Code 采用应用层权限控制——每次文件操作需用户确认（可用 --dangerously-skip-permissions 跳过），设置不持久化。依赖模型自身遵守系统指令，无硬隔离边界。

核心差异：OS 级隔离防止模型被对抗性提示越狱；应用层隔离假设模型善意，仅防意外误操作。前者安全性更高，后者用户体验更流畅但需信任模型。

追问：为什么 Codex 选择 OS 级隔离？Seatbelt 如何精确限制网络访问？Docker 网络隔离的内核机制是什么？

区分度：基础层知道有沙箱；进阶层理解 Seatbelt/Docker 实现；专家层掌握强制访问控制（MAC）原理和沙箱逃逸防护。

## Post 4

【面试题】CLAUDE.md 与 AGENTS.md 的作用和差异？如何编写高质量项目配置？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 项目长期记忆 / 分层配置 / 生态兼容性 / 实证数据 | 中 | 进阶 |

回答要点：Claude Code 仅支持 CLAUDE.md 单文件配置；Codex 支持 AGENTS.md 分层标准（全局→仓库→子文件夹继承），与 Cursor、Builder.io 等工具生态兼容。基于 328 个项目的实证研究，配置文件常见内容包括软件架构（72.6%）、开发指南（44.8%）、项目概览（39%）、测试说明（35.4%）、常用命令（33.2%）。

最佳实践："架构+依赖+概述"三元组是高性价比组合。架构描述应包含目录结构、模块职责、通信协议；依赖管理需列出关键库及版本；项目概要简述目标用户和核心功能。

常见误区：认为配置文件只是简单文档。实际是 AI 代码库的心智模型基础，缺失会导致工具"瞎子摸象"。

追问：为什么架构信息出现率最高？分层配置继承规则如何设计冲突解决？如何平衡详略（过度详细 vs 信息不足）？

区分度：基础层知道配置文件存在；进阶层理解常见内容模式；专家层掌握"三元组+场景化指令+示例代码"结构。

## Post 5

【面试题】显式规划 vs 隐式规划：TodoWrite 和 /think 模式各有什么优缺点？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 任务规划机制 / 上下文注入策略 / 防遗忘设计 | 中 | 进阶 |

回答要点：Claude Code 用 TodoWrite 工具显式展示计划，创建交互式检查清单；每次工具调用后，系统自动注入当前 TODO 状态，防止模型在长对话中迷失目标。Codex 采用隐式规划，通过"尝试-观察-修正"迭代推进，无专门任务列表。

显式规划优点：用户可审查和调整计划，长任务不会失焦；缺点是额外 Token 消耗，过度计划可能延误执行。隐式规划优点：启动快，适合探索式任务；缺点是在复杂多步任务中容易偏离目标，用户难以干预。

关键机制：Claude Code 用全量更新模式而非增量更新，确保 TODO 状态始终一致；/think 模式允许内部推理但不输出到对话，避免干扰用户。

追问：为什么全量更新而非增量？如何评估规划粒度（过细 vs 过粗）？是否可以混合策略？

区分度：基础层知道有任务列表；进阶层理解上下文注入机制；专家层掌握防遗忘设计和规划-执行解耦。

## Post 6

【面试题】两者在代码审查上的表现差异？为什么 Codex 被认为"实干家"而 Claude Code "理论家"？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| GitHub 集成 / 交互式修复 / 审查质量评估 | 中 | 进阶 |

回答要点：Codex 的 GitHub 应用支持行内评论+交互式修复，能发现"合法的、难以发现的 bug"（如空指针、边界条件），用户可直接点击应用修复。Claude Code 被批评为"verbose without catching obvious bugs"——生成大量文字建议但漏掉明显错误，且缺少与 GitHub 的深度集成。

Builder.io 团队实际使用反馈：GPT-5 的用户满意度比 Claude Sonnet 高 40%。关键差异在于一致性体验（CLI = GitHub UI）和实战导向 vs 理论完美主义。

Codex 优势：模型训练方自研工具，对 diff 格式和 GitHub API 有原生优化；审查结果可直接转化为 PR 评论，形成闭环。Claude Code 优势：在大型代码库分析、架构重构建议上更全面。

追问：如何量化代码审查质量？"啰嗦但漏掉明显 bug"的根源是什么？如何改进 Claude Code 的审查能力？

区分度：基础层知道 Codex 审查更好；进阶层理解交互式修复流程；专家层掌握"实干家 vs 理论家"评价维度和产品-模型协同效应。

## Post 7

【面试题】GPT-5 vs Claude Sonnet/Opus 的成本差异？为什么 GPT-5 效率更高？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| Token 效率 / 定价策略 / 使用限制 / 训练方自研优势 | 中 | 进阶 |

回答要点：GPT-5 成本约为 Sonnet 的一半、Opus 的 1/10。实际使用中，Codex Pro（$20/月）几乎没人报告触碰限制；Claude 在 $17 层级很快用完，$100/$200 层级重度用户仍碰天花板。

效率差异来源：（1）GPT-5 用更激进的量化压缩，推理成本更低；（2）模型训练方自研工具，对 diff 格式和上下文管理有针对性优化；（3）Codex 的懒加载策略减少无效 Token 消耗；（4）Shell 优先设计无需额外工具 API 封装层。

实战影响：在大型项目中，Token 效率差异会放大 5-10 倍。选择时需考虑使用场景——高频小任务选 Codex，低频大任务选 Claude 可能更合适（但要监控用量）。

追问：为什么 Claude 更容易触碰使用限制？定价策略背后的用户筛选逻辑？如何评估成本-质量权衡？

区分度：基础层知道 Codex 更便宜；进阶层理解 Token 效率差异；专家层掌握推理成本优化和产品策略分析。

## Post 8

【面试题】单代理 ReAct 为什么仍是主流？其"可控性"是如何被工程化的？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| Agent 循环 / 可控性工程 / 失败模式 | 中高 | 进阶 |

回答要点：单代理 ReAct 将"思考→工具→观察"串成确定序列，便于回放与审计；通过"工具调用 + 结果注入"的闭环，压缩自由生成范围，减少不可解释行为；关键操作被显式记录（读文件/改动/测试），形成可追溯链。失败模式集中在长任务漂移、工具误用与上下文污染；工程补救包括显式计划（TodoWrite/Checklist）、最小 diff 编辑、权限分级与执行前后状态快照。取舍上牺牲吞吐换可控性，适合高风险修改与生产环境。

常见误区：把"单代理 = 能力弱"。本质是控制面设计，不是模型能力差异。

追问：哪些任务值得牺牲可控性换吞吐？如何避免并行带来的状态不一致？

区分度：基础层知道单代理便于调试；进阶层能讲清 diff 对审计的价值；专家层能设计可审计的并行折中方案。

## Post 9

【面试题】结构化工具链 vs Shell-first：控制面设计如何影响安全、效率与扩展？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 工具封装哲学 / 控制面 / 扩展成本 | 中高 | 进阶 |

回答要点：结构化工具可对输入/输出做 schema 约束，便于权限分级与审计；Shell-first 复用系统工具链，启动成本低、组合能力强，但安全边界依赖 OS 权限模型。结构化工具易做缓存与可视化，但新增能力需接口开发；Shell-first 扩展靠命令组合，成本低但可观察性弱。失败模式上，结构化工具易受 schema 误设影响，Shell-first 易出现命令副作用，需要更严格的执行约束。

常见误区：把结构化工具理解为"功能少"。它是可控性优先的控制面设计。

追问：在 Shell-first 体系中如何实现细粒度权限？你会怎么设计最小安全封装？

区分度：基础层能对比工具形态；进阶层能解释控制面差异；专家层能给出场景化权衡。

## Post 10

【面试题】懒加载与主动扫描如何影响"正确性 vs 成本"？如何做自适应策略？

| 考察点 | 面试频率 | 难度 |
| --- | --- | --- |
| 上下文加载策略 / 依赖完整性 / 成本控制 | 中 | 进阶 |

回答要点：懒加载的优势是 token 成本低、启动快、可控性强，但容易遗漏隐式依赖（跨模块调用、配置注入、动态加载），导致推理断裂；主动扫描能构建完整代码库心智模型，对重构更稳，但成本高、易触发上下文压缩与噪音干扰。自适应策略可分三层：先加载目录树与关键配置，再按调用链深度增量加载，最后根据任务复杂度与变更范围触发扫描升级；配合项目地图文件（AGENTS.md/CLAUDE.md）与关键入口白名单降低遗漏。

常见误区：把懒加载当作绝对优势，忽视遗漏成本。

追问：如何量化依赖遗漏风险？哪些指标触发扫描升级？

区分度：基础层知道懒加载风险；进阶层能给出补救方案；专家层能提出自适应策略。
